import re
import pcre2
import time
import json


def re_search(pattern, text, global_search=True, caseless=False, multiline=False, dotall=False):
    """
    Perform a regex search using Python's built-in `re` module.

    Args:
        pattern (str): The regex pattern to search for.
        text (str): The text to search within.
        global_search (bool): If True, perform a global search (find all matches).
                             If False, return only the first match.
        caseless (bool): If True, enable case-insensitive matching (re.IGNORECASE).
        multiline (bool): If True, enable multiline mode (re.MULTILINE).
        dotall (bool): If True, enable dot-all mode (re.DOTALL).

    Returns:
        dict: A JSON-like structure containing metadata and match details.
    """
    # Start timing the execution
    start_time = time.time()

    # Configure flags
    flags = 0
    if caseless:
        flags |= re.IGNORECASE
    if multiline:
        flags |= re.MULTILINE
    if dotall:
        flags |= re.DOTALL

    # Compile the regular expression pattern with flags
    compiled_pattern = re.compile(pattern, flags)

    # List to store all matches
    matches = []

    # Perform search based on global_search flag
    if global_search:
        # Find all matches
        re_matches = list(compiled_pattern.finditer(text))
    else:
        # Find only the first match
        re_matches = [compiled_pattern.search(text)] if compiled_pattern.search(text) else []

    # Extract match details
    for match in re_matches:
        match_start = match.start()
        match_length = match.end() - match.start()
        groups = []

        # Extract captured groups
        for i in range(1, len(match.groups()) + 1):  # Groups are 1-indexed
            group_start = match.start(i)
            group_length = match.end(i) - match.start(i)
            groups.append({
                "i": group_start,
                "l": group_length
            })

        # Store the match and captured groups
        matches.append({
            "i": match_start,
            "l": match_length,
            "groups": groups
        })

    # Calculate runtime
    runtime = time.time() - start_time

    # Build the JSON-like structure
    result = {
        "success": True,
        "data": {
            "id": None,
            "timestamp": int(time.time()),  # Current Unix timestamp
            "time": round(runtime, 4),  # Runtime in seconds, rounded to 4 decimal places
            "matches": matches,
            "mode": "text",
            "tool": {
                "id": "explain",
                "result": ""
            }
        },
        "metadata": {
            "script-time": f"{runtime * 1000:.2f}ms"  # Runtime in milliseconds
        }
    }

    return result



######### FIXED PCRE2
def pcre2_search(pattern, text, global_search=True, caseless=False, multiline=False, dotall=False):
    """
    Perform a PCRE2 regex search on the given text with support for flags.

    Args:
        pattern (str): The regex pattern to search for.
        text (str): The text to search within.
        global_search (bool): If True, perform a global search (find all matches).
                             If False, return only the first match.
        caseless (bool): If True, enable case-insensitive matching (PCRE2_CASELESS).
        multiline (bool): If True, enable multiline mode (PCRE2_MULTILINE).
        dotall (bool): If True, enable dot-all mode (PCRE2_DOTALL).

    Returns:
        dict: A JSON-like structure containing metadata and match details.
    """
    # Start timing the execution
    start_time = time.time()

    # Define PCRE2 flag values
    PCRE2_CASELESS = 0x00000008  # Case-insensitive matching
    PCRE2_MULTILINE = 0x00000400  # Multiline mode
    PCRE2_DOTALL = 0x00000010  # Dot-all mode

    # Configure flags
    flags = 0
    if caseless:
        flags |= PCRE2_CASELESS
    if multiline:
        flags |= PCRE2_MULTILINE
    if dotall:
        flags |= PCRE2_DOTALL

    # Compile the regular expression pattern with flags
    compiled_pattern = pcre2.compile(pattern, flags)

    # Initialize the starting position for the search
    start_pos = 0

    # List to store all matches
    matches = []

    # Perform iterative search
    while True:
        try:
            # Search for the pattern starting from `start_pos`
            match = compiled_pattern.match(text, start_pos)
        except pcre2.exceptions.MatchError:
            break  # No more matches found

        # Extract match details
        match_start = match.start()
        match_length = len(match[0])
        groups = []

        # Extract captured groups
        i = 1  # Start with the first capturing group
        while True:
            try:
                # Attempt to access the next group
                group = match[i]
                group_start = match.start(i)
                group_length = len(group)
                groups.append({
                    "i": group_start,
                    "l": group_length
                })
                i += 1
            except pcre2.exceptions.LibraryError:
                # No more groups available
                break

        # Store the match and captured groups
        matches.append({
            "i": match_start,
            "l": match_length,
            "groups": groups
        })

        # If not performing a global search, break after the first match
        if not global_search:
            break

        # Update the starting position to the end of the current match
        start_pos = match.end()  # Move start_pos to the end of the current match

    # Calculate runtime
    runtime = time.time() - start_time

    # Build the JSON-like structure
    result = {
        "success": True,
        "data": {
            "id": None,
            "timestamp": int(time.time()),  # Current Unix timestamp
            "time": round(runtime, 4),  # Runtime in seconds, rounded to 4 decimal places
            "matches": matches,
            "mode": "text",
            "tool": {
                "id": "explain",
                "result": ""
            }
        },
        "metadata": {
            "script-time": f"{runtime * 1000:.2f}ms"  # Runtime in milliseconds
        }
    }

    return result






# text = "The dates are 2023-10-05 and 2024-01-15.\nAlso, 2022-12-25 is a special date."

# result = re_search(
#     r'(\d{4})-(\d{2})-(\d{2})',
#     text,
#     global_search=True,
#     caseless=True,  # Case-insensitive matching
#     multiline=True,  # ^ and $ match start/end of lines
#     dotall=True      # . matches newline characters
# )
# print(json.dumps(result, indent=4))

# result = pcre2_search(
#     r'(\d{4})-(\d{2})-(\d{2})',
#     text,
#     global_search=True,
#     caseless=True,  # Case-insensitive matching
#     multiline=True,  # ^ and $ match start/end of lines
#     dotall=True      # . matches newline characters
# )
# print(json.dumps(result, indent=4))


def compare_searches(pattern, text, global_search=True, caseless=False, multiline=False, dotall=False):
    """
    Compare the results and performance of re_search and pcre2_search.

    Args:
        pattern (str): The regex pattern to search for.
        text (str): The text to search within.
        global_search (bool): If True, perform a global search (find all matches).
                             If False, return only the first match.
        caseless (bool): If True, enable case-insensitive matching.
        multiline (bool): If True, enable multiline mode.
        dotall (bool): If True, enable dot-all mode.

    Returns:
        dict: A comparison of results and performance.
    """
    # Run re_search
    re_start_time = time.time()
    re_result = re_search(pattern, text, global_search, caseless, multiline, dotall)
    re_runtime = time.time() - re_start_time

    # Run pcre2_search
    pcre2_start_time = time.time()
    pcre2_result = pcre2_search(pattern, text, global_search, caseless, multiline, dotall)
    pcre2_runtime = time.time() - pcre2_start_time

    # Compare results
    comparison = {
        "re_result": re_result,
        "pcre2_result": pcre2_result,
        "runtime_comparison": {
            "re_runtime_ms": re_runtime * 1000,
            "pcre2_runtime_ms": pcre2_runtime * 1000,
            "difference_ms": (pcre2_runtime - re_runtime) * 1000
        },
        "match_comparison": {
            "matches_equal": re_result["data"]["matches"] == pcre2_result["data"]["matches"],
            "re_matches_count": len(re_result["data"]["matches"]),
            "pcre2_matches_count": len(pcre2_result["data"]["matches"])
        }
    }

    return comparison

# Test cases
test_cases = [
    {
        "pattern": r'(\d{4})-(\d{2})-(\d{2})',
        "text": "The dates are 2023-10-05 and 2024-01-15.\nAlso, 2022-12-25 is a special date.",
        "global_search": True,
        "caseless": True,
        "multiline": True,
        "dotall": True
    },
    {
        "pattern": r'\b\w+\b',
        "text": "This is a simple test.",
        "global_search": True,
        "caseless": False,
        "multiline": False,
        "dotall": False
    },
    {
        "pattern": r'^[A-Z]',
        "text": "this is a test.\nThis is another test.",
        "global_search": True,
        "caseless": True,
        "multiline": True,
        "dotall": False
    },
    {
        "pattern": r'nonexistent',
        "text": "This text does not contain the pattern.",
        "global_search": True,
        "caseless": False,
        "multiline": False,
        "dotall": False
    }
]

# Run comparisons
for i, test_case in enumerate(test_cases):
    print(f"Test Case {i+1}:")
    comparison = compare_searches(**test_case)
    print(json.dumps(comparison, indent=4))
    print("\n" + "="*80 + "\n")
    

####################################################################################################
from setuptools import setup, Extension
import pybind11

# Define the extension module
module = Extension(
    'boost_regex',
    sources=['boost_regex_wrapper.cpp'],
    include_dirs=[
        pybind11.get_include(),
        '/usr/include',  # Path to Boost headers
    ],
    library_dirs=['/home/jcodispo/dev/cpp/boost_1_87_0/stage/lib/usr/lib/x86_64-linux-gnu'],  # Path to Boost.Regex library
    libraries=['boost_regex'],
    language='c++',
    extra_compile_args=['-std=c++11'],
)

# Setup the module
setup(
    name='boost_regex',
    version='1.0',
    description='Python bindings for Boost.Regex',
    ext_modules=[module],
)


####################################################################################################
#include <boost/xpressive/xpressive.hpp>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>  // For std::vector and std::string support

namespace py = pybind11;
namespace xp = boost::xpressive;

// Function to match a regex pattern against a string
bool match(const std::string& pattern, const std::string& text, int flags = 0) {
    xp::sregex_compiler compiler;
    xp::sregex regex;

    // Map flags to Boost.Xpressive flags
    if (flags & 0x0001) {  // PCRE2_CASELESS
        regex = compiler.compile(pattern, xp::icase);
    } else {
        regex = compiler.compile(pattern);
    }

    // Perform the search (to check if the pattern exists anywhere in the text)
    return xp::regex_search(text, regex);
}

// Function to search for a regex pattern in a string
bool search(const std::string& pattern, const std::string& text, int flags = 0) {
    xp::sregex_compiler compiler;
    xp::sregex regex;

    // Map flags to Boost.Xpressive flags
    if (flags & 0x0001) {  // PCRE2_CASELESS
        regex = compiler.compile(pattern, xp::icase);
    } else {
        regex = compiler.compile(pattern);
    }

    // Perform the search
    return xp::regex_search(text, regex);
}

// Function to replace occurrences of a regex pattern in a string
std::string replace(const std::string& pattern, const std::string& text, const std::string& fmt, bool replace_all = true, int flags = 0) {
    xp::sregex_compiler compiler;
    xp::sregex regex;

    // Map flags to Boost.Xpressive flags
    if (flags & 0x0001) {  // PCRE2_CASELESS
        regex = compiler.compile(pattern, xp::icase);
    } else {
        regex = compiler.compile(pattern);
    }

    // Perform the replacement
    if (replace_all) {
        return xp::regex_replace(text, regex, fmt);
    } else {
        return xp::regex_replace(text, regex, fmt, xp::regex_constants::format_first_only);
    }
}

// Create the Python module
PYBIND11_MODULE(boost_regex, m) {
    m.def("match", &match, "Search for a regex pattern in a string (anywhere in the text)",
          py::arg("pattern"), py::arg("text"), py::arg("flags") = 0);
    m.def("search", &search, "Search for a regex pattern in a string",
          py::arg("pattern"), py::arg("text"), py::arg("flags") = 0);
    m.def("replace", &replace, "Replace occurrences of a regex pattern in a string",
          py::arg("pattern"), py::arg("text"), py::arg("fmt"), py::arg("replace_all") = true, py::arg("flags") = 0);
}
####################################################################################################
import boost_regex

def test_match(pattern, text, flags=0, expected=True):
    result = boost_regex.match(pattern, text, flags)
    print(f"Testing match: pattern='{pattern}', text='{text}', flags={flags} -> Result: {result} (Expected: {expected})")
    assert result == expected, f"Test failed! Expected {expected}, got {result}"

def test_search(pattern, text, flags=0, expected=True):
    result = boost_regex.search(pattern, text, flags)
    print(f"Testing search: pattern='{pattern}', text='{text}', flags={flags} -> Result: {result} (Expected: {expected})")
    assert result == expected, f"Test failed! Expected {expected}, got {result}"

def test_replace(pattern, text, fmt, replace_all=True, flags=0, expected=None):
    result = boost_regex.replace(pattern, text, fmt, replace_all, flags)
    print(f"Testing replace: pattern='{pattern}', text='{text}', fmt='{fmt}', replace_all={replace_all}, flags={flags} -> Result: '{result}' (Expected: '{expected}')")
    if expected is not None:
        assert result == expected, f"Test failed! Expected '{expected}', got '{result}'"

# Test cases
if __name__ == "__main__":
    # Test match function
    test_match("hello", "Hello world", flags=0, expected=False)
    test_match("hello", "Hello world", flags=0x0001, expected=True)

    # Test search function
    test_search("hello", "Hello world", flags=0, expected=False)
    test_search("hello", "Hello world", flags=0x0001, expected=True)

    # Test replace function
    test_replace("hello", "Hello world", "hi", replace_all=True, flags=0x0001, expected="hi world")
    test_replace("hello", "Hello world, hello universe", "hi", replace_all=False, flags=0x0001, expected="hi world, hello universe")

    print("\nAll tests completed!")


####################################################################################################














